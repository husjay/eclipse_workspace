package soultion.ooj_containerWithMostWater;

/**
 * 盛最多水的容器
 * 问题：给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
 * 	画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的
 * 	两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
 * 思路1:使用双重循环找出最大的面积
 * 思路2:从两端向中间靠拢，每次选择两端高度height低的向中间移动
 * 		原理：再从两端向中间靠拢的过程中，如果要使面积大于当前面积，那么高度一定比当前两端的都要高，
 * 			 因为在向中间靠拢的过程中宽度一直在减小。
 * @author hsj
 *
 */
public class ContainerWithMostWater {
	
	
	
	public static void main(String[] args) {
		int[] height = {15000,14999,14998,14997,14996,14995,14994,14993,
				14992,14991,14990,14989,14988,14987,14986,14985,14984,14983,
				14982,14981,14980,14979,14978,14977,14976,14975,14974,14973,
				14972,14971,14970,14969,14968,14967,14966,14965,14964,14963,
				14962,14961,14960,14959,14958,14957,14956,14955,14954,14953,
				14952,14951,14950,14949,14948,14947,14946,14945,14944,14943,
				14942,14941,14940,14939,14938,14937,14936,14935,14934,14933,
				14932,14931,14930,14929,14928,14927,14926,14925,14924,14923,
				14922,14921,14920,14919,14918,14917,14916,14915,14914,14913,
				14912,14911,14910,14909,14908,14907,14906,14905,14904,14903,
				14902,14901,14900,14899,14898,14897,14896,14895,14894,14893,
				14892,14891,14890,14889,14888,14887,14886,14885,14884,14883,
				14882,14881,14880,14879,14878,14877,14876,14875,14874,14873,
				14872,14871,14870,14869,14868,14867,14866,14865,14864,14863};
		System.out.println(maxArea_2(height));
	}
	
	public static int maxArea_1(int[] height) {
        
		int maxArea = 0;
		for(int i=0; i<height.length; i++) {
			int h_i = height[i];
			for(int j=i+1; j<height.length; j++) {
				int h_j = height[j];
				int h = h_i < h_j? h_i: h_j;
				int area = (j-i) * h;
				if(area > maxArea) {
					maxArea = area;
				}
			}
		}
		
		return maxArea;
    }
	
	public static int maxArea_2(int[] height) {
		int i = 0, j = height.length - 1;
		int maxArea = 0;
		int h_i, h_j, area; 
		while(i < j) {
			h_i = height[i];
			h_j = height[j];
			
			area = (j-i)* Math.min(h_i, h_j);
			maxArea = Math.max(maxArea, area);
			
			if(h_i < h_j) {
				i++;
				while(i<j && h_i >= height[i])i++;
			} else {
				j--;
				while(i<j && h_j >= height[j])j--;
			}
		}
		
		return maxArea;
    }

}
